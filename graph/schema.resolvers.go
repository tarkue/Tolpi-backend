package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"

	"github.com/tarkue/tolpi-backend/database"
	"github.com/tarkue/tolpi-backend/graph/model"
)

var db = database.Connect()
var ActualTolpi = &model.Tolpi{}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	return db.CreateUser(&input), nil
}

// CreateTolpi is the resolver for the createTolpi field.
func (r *mutationResolver) CreateTolpi(ctx context.Context, input model.NewTolpi) (*model.Tolpi, error) {
	tolpi := db.CreateTolpi(&input)

	ActualTolpi = tolpi

	return tolpi, nil
}

// Tolpies is the resolver for the Tolpies field.
func (r *queryResolver) Tolpies(ctx context.Context) ([]*model.Tolpi, error) {
	return db.GetLastTolpies(), nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, userID string) (*model.User, error) {
	return db.FindUserById(userID), nil
}

// Tolpies is the resolver for the Tolpies field.
func (r *subscriptionResolver) Tolpies(ctx context.Context) (<-chan []*model.Tolpi, error) {
	ch := make(chan []*model.Tolpi)

	var Tolpies []*model.Tolpi
	go func() {
		for {
			if len(Tolpies) > 0 {
				if Tolpies[len(Tolpies)-1] != ActualTolpi {
					Tolpies = append(Tolpies, ActualTolpi)
					ch <- Tolpies
				}
			} else {
				if ActualTolpi.Text != "" {
					Tolpies = append(Tolpies, ActualTolpi)
					ch <- Tolpies
				}
			}
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
