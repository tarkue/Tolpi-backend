package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.36

import (
	"context"
	"log"

	"github.com/tarkue/tolpi-backend/internal/app/database"
	"github.com/tarkue/tolpi-backend/internal/app/graph/model"
)

var db = database.New()
var ActualTolpi = &model.Tolpi{}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	return db.CreateUser(&input), nil
}

// CreateTolpi is the resolver for the createTolpi field.
func (r *mutationResolver) CreateTolpi(ctx context.Context, input model.NewTolpi) (*model.Tolpi, error) {
	tolpi := db.CreateTolpi(&input)

	ActualTolpi = tolpi

	return tolpi, nil
}

// Tolpies is the resolver for the Tolpies field.
func (r *queryResolver) Tolpies(ctx context.Context, country string) ([]*model.Tolpi, error) {
	return db.GetLastTolpies(country), nil
}

// User is the resolver for the User field.
func (r *queryResolver) User(ctx context.Context, userID string) (*model.User, error) {
	return db.FindUserById(userID), nil
}

// Tolpies is the resolver for the Tolpies field.
func (r *subscriptionResolver) Tolpies(ctx context.Context, userID string) (<-chan []*model.Tolpi, error) {
	ch := make(chan []*model.Tolpi)

	var usersId []string
	users := db.GetSubscribes(userID)
	if len(users) > 0 {
		for i := 0; i < len(users); i++ {
			usersId = append(usersId, users[i].UserID)
		}
	} else {
		return ch, nil
	}

	log.Print(usersId)

	var Tolpies []*model.Tolpi
	go func() {
		for {
			if ActualTolpi.Text != "" {
				if len(Tolpies) > 0 {
					if Contains(usersId, ActualTolpi.User.UserID) {
						if Tolpies[len(Tolpies)-1] != ActualTolpi {
							Tolpies = append(Tolpies, ActualTolpi)
							ch <- Tolpies
						}
					}
				} else {
					if Contains(usersId, ActualTolpi.User.UserID) {
						Tolpies = append(Tolpies, ActualTolpi)
						ch <- Tolpies
					}
				}
			}
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

func Contains(a []string, x string) bool {
	for _, n := range a {
		if x == n {
			return true
		}
	}
	return false
}
